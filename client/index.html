<!--
 Copyright 2025 Google LLC

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->
 
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Project Pastra</title>
  <link rel="stylesheet" href="styles/style.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
  
  <!-- Favicon -->
  <link rel="icon" type="image/x-icon" href="assets/favicon.ico">
</head>
<body>
  <div class="container">
    <h1>Project Pastra</h1>
    <p>Speak into your microphone and optionally share your webcam or screen to engage in a multimedia conversation.</p>
  </div>

  <div class="input-container">
    <button id="micButton" disabled class="action-button">
      <span class="material-symbols-outlined">mic</span>
    </button>
    <button id="webcamButton" class="action-button">
      <span class="material-symbols-outlined">videocam</span>
    </button>
    <button id="screenButton" class="action-button">
      <span class="material-symbols-outlined">present_to_all</span>
    </button>
    <button id="uploadImageButton" class="action-button">
      <span class="material-symbols-outlined">upload_file</span>
    </button>
    <input type="file" id="imageUploadInput" accept="image/*" style="display: none;"/>
    <div class="text-input-container">
      <input type="text" id="textInput" placeholder="Type your message..." class="text-input">
      <button id="sendButton" class="action-button">
        <span class="material-symbols-outlined">send</span>
      </button>
      <button id="interruptButton" class="action-button" style="display: none;">
        <span class="material-symbols-outlined">cancel</span>
      </button>
    </div>
  </div>

  <!-- Modality Radio Buttons -->
  <div class="modality-radio-container">
    <span class="modality-label">Response:</span>
    <input type="radio" id="modalityAudio" name="modality" value="AUDIO" checked>
    <label for="modalityAudio">Audio</label>
    <input type="radio" id="modalityText" name="modality" value="TEXT">
    <label for="modalityText">Text</label>
  </div>
  <!-- End Modality Radio Buttons -->

  <!-- Connect Button -->
  <div class="connect-container">
    <button id="connectButton" class="action-button connect-button">Connect</button>
  </div>
  <!-- End Connect Button -->

  <div class="video-container">
    <video id="videoPreview" autoplay playsinline class="hidden"></video>
  </div>

  <div id="output"></div>

  <!-- Load EventEmitter3 first -->
  <script src="https://cdn.jsdelivr.net/npm/eventemitter3@5.0.1/dist/eventemitter3.umd.min.js"></script>

  <script type="module">
    import { AudioRecorder } from './src/audio/audio-recorder.js';
    import { AudioStreamer } from './src/audio/audio-streamer.js';
    import { MediaHandler } from './src/media/media-handler.js';
    import { GeminiAPI } from './src/api/gemini-api.js';
    import { base64ToArrayBuffer } from './src/utils/utils.js';

    // Initialize components
    const output = document.getElementById('output');
    const audioRecorder = new AudioRecorder();
    const audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 24000 });
    const audioStreamer = new AudioStreamer(audioContext);
    const mediaHandler = new MediaHandler();
    const wsEndpoint = 'ws://localhost:8081';
    let api = null; // Declare api, instantiate on first interaction
    let isApiReady = false; // Track if the API connection/setup is complete

    let isRecording = false;
    let hasShownSpeakingMessage = false;
    let currentTurn = 0;
    let lastAudioTurn = -1;
    let responseModality = 'AUDIO'; // Default to Audio

    // Modality Toggle Elements -- REMOVE
    // const modalityToggle = document.getElementById('modalityToggle');
    // const modalityLabel = document.getElementById('modalityLabel');
    // Modality Radio Button Elements
    const modalityRadios = document.querySelectorAll('input[name="modality"]');
    const modalityAudioRadio = document.getElementById('modalityAudio');
    const modalityTextRadio = document.getElementById('modalityText');

    // Button Elements
    const connectButton = document.getElementById('connectButton');
    const micButton = document.getElementById('micButton');
    const sendButton = document.getElementById('sendButton');
    const uploadImageButton = document.getElementById('uploadImageButton');

    // Initialize media handler
    mediaHandler.initialize(document.getElementById('videoPreview'));

    // Function to initialize API connection if needed
    async function ensureApiConnected() {
      if (api && isApiReady) {
        return; // Already connected and ready
      }

      if (!api) {
        console.log('API not initialized. Connecting...');
        api = new GeminiAPI(wsEndpoint);

        // Set up API handlers (needs to be done after instantiation)
        api.onReady = () => {
          console.log('API received ready signal from backend.');
          // Don't enable mic button here anymore
          // document.getElementById('micButton').disabled = false;
          isApiReady = true; // Mark API as ready *after* server confirms
        };

        api.onConnect = () => {
          console.log('WebSocket connected, sending modality:', responseModality);
          // Send setup *after* ready signal is confirmed by onReady setting isApiReady
          api.sendSetupMessage({ modality: responseModality }); 
        };

        // Re-assign all other handlers
        api.onAudioData = async (audioData) => {
          if (responseModality === 'TEXT') return;
          try {
            if (!api.isSpeaking || lastAudioTurn !== currentTurn) {
              logMessage('Gemini: Speaking...');
              api.isSpeaking = true;
              lastAudioTurn = currentTurn;
              document.getElementById('interruptButton').style.display = 'inline-block';
            }
            const arrayBuffer = base64ToArrayBuffer(audioData);
            audioStreamer.addPCM16(new Uint8Array(arrayBuffer));
            audioStreamer.resume();
          } catch (error) {
            console.error('Error playing audio:', error);
          }
        };
        api.onTextContent = (text) => {
          if (text.trim()) {
            logMessage('Gemini: ' + text);
          }
        };
        api.onTurnComplete = () => {
          logMessage('Gemini: Finished speaking');
          api.isSpeaking = false;
          audioStreamer.complete();
          document.getElementById('interruptButton').style.display = 'none';
        };
        api.onInterrupted = (data) => {
          logMessage('Gemini: Response interrupted');
          api.isSpeaking = false;
          audioStreamer.stop();
          document.getElementById('interruptButton').style.display = 'none';
          const messageElement = document.createElement('p');
          messageElement.className = 'interrupted-message';
          messageElement.textContent = 'Response interrupted by user input';
          output.appendChild(messageElement);
          output.scrollTop = output.scrollHeight;
        };
        api.onFunctionCall = (data) => {
          logMessage('Function: ' + data.name);
          logMessage('Parameters: ' + JSON.stringify(data.args, null, 2));
        };
        api.onFunctionResponse = (data) => {
          logMessage('API Response: ' + JSON.stringify(data, null, 2));
        };
        api.onError = (errorData) => { // Add error handler assignment
            console.error("API Error:", errorData);
            logMessage(`Error: ${errorData.message} ${errorData.action || ''}`);
            // Potentially disable buttons or show overlay
            document.getElementById('micButton').disabled = true;
        };

        // Start the connection process (returns the ready promise)
        api.connect(); // Explicitly start connection after assigning handlers

      } 
      // Wait until the API confirms it's ready (WebSocket open + server ready signal)
      await api.ensureReady(); 
    }

    // ---- Interaction Button State ----
    function setInteractionButtonsDisabled(disabled) {
        micButton.disabled = disabled;
        sendButton.disabled = disabled;
        uploadImageButton.disabled = disabled;
        // Also disable text input field
        document.getElementById('textInput').disabled = disabled;
    }
    // Initially disable interaction buttons
    setInteractionButtonsDisabled(true);
    // ---- End Interaction Button State ----

    // UI Event Handlers
    async function startRecording() {
      try {
        // await ensureApiConnected(); // Connection is now ensured by Connect button

        // If model is speaking, treat this as an interruption
        if (api.isSpeaking) {
          audioStreamer.stop();
          api.isSpeaking = false;
        }

        await audioContext.resume();
        await audioRecorder.start();
        hasShownSpeakingMessage = false;
        currentTurn++;
        
        audioRecorder.on('data', (base64Data) => {
          if (!hasShownSpeakingMessage) {
            logMessage('You: Speaking...');
            hasShownSpeakingMessage = true;
          }
          api.sendAudioChunk(base64Data);
        });

        isRecording = true;
        document.getElementById('micButton').innerHTML = 
          '<span class="material-symbols-outlined">stop</span>';
      } catch (error) {
        console.error('Error starting recording:', error);
        logMessage('Error: ' + error.message);
      }
    }

    function stopRecording() {
      audioRecorder.stop();
      isRecording = false;
      hasShownSpeakingMessage = false;
      document.getElementById('micButton').innerHTML = 
        '<span class="material-symbols-outlined">mic</span>';
      logMessage('You: Recording stopped.');
      
      // Stop video streams
      mediaHandler.stopAll();
      document.getElementById('webcamButton').innerHTML = 
        '<span class="material-symbols-outlined">videocam</span>';
      document.getElementById('screenButton').innerHTML = 
        '<span class="material-symbols-outlined">present_to_all</span>';
      
      api.sendEndMessage();
      api.isSpeaking = false;
    }

    function logMessage(message) {
      const messageElement = document.createElement('p');
      
      // Add specific styling based on message content
      if (message.startsWith('Function:')) {
        messageElement.className = 'function-name';
      } else if (message.startsWith('Parameters:')) {
        messageElement.className = 'function-params';
      } else if (message.startsWith('API Response:')) {
        messageElement.className = 'api-response';
      } else if (message === 'Gemini: Finished speaking') { // Specific check for turn complete
        messageElement.className = 'turn-complete-message';
      } else if (message.startsWith('Gemini:')) { // General Gemini message
        messageElement.className = 'gemini-message';
      } else if (message.startsWith('You:')) {
        messageElement.className = 'user-message';
      }
      
      messageElement.textContent = message;
      output.appendChild(messageElement);
      output.scrollTop = output.scrollHeight;
    }

    // Add function to send text message
    async function sendTextMessage() { // Make async
      const textInput = document.getElementById('textInput');
      const text = textInput.value.trim();
      if (!text || !api) return; // Add !api check

      // await ensureApiConnected(); // Connection is now ensured by Connect button

      // Clear input
      textInput.value = '';

      // Log user message
      logMessage('You: ' + text);

      // Send text message
      api.sendTextMessage(text);
    }

    // Set up button click handlers
    document.getElementById('micButton').onclick = () => {
      if (isRecording) {
        stopRecording();
      } else {
        startRecording();
      }
    };

    // Add send button handler
    document.getElementById('sendButton').onclick = sendTextMessage;

    // Add keypress handler for text input
    document.getElementById('textInput').addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        sendTextMessage();
      }
    });

    document.getElementById('webcamButton').onclick = async () => {
      if (mediaHandler.isWebcamActive) {
        mediaHandler.stopAll();
        document.getElementById('webcamButton').innerHTML = 
          '<span class="material-symbols-outlined">videocam</span>';
      } else {
        const success = await mediaHandler.startWebcam();
        if (success) {
          document.getElementById('webcamButton').innerHTML = 
            '<span class="material-symbols-outlined">videocam_off</span>';
          mediaHandler.startFrameCapture((base64Image) => {
            api.sendImage(base64Image);
          });
        }
      }
    };

    document.getElementById('screenButton').onclick = async () => {
      if (mediaHandler.isScreenActive) {
        mediaHandler.stopAll();
        document.getElementById('screenButton').innerHTML = 
          '<span class="material-symbols-outlined">present_to_all</span>';
      } else {
        const success = await mediaHandler.startScreenShare();
        if (success) {
          document.getElementById('screenButton').innerHTML = 
            '<span class="material-symbols-outlined">cancel_presentation</span>';
          mediaHandler.startFrameCapture((base64Image) => {
            api.sendImage(base64Image);
          });
        }
      }
    };

    // Add CSS for interrupted message
    const style = document.createElement('style');
    style.textContent = `
      .interrupted-message {
        color: #ff6b6b;
        font-style: italic;
        margin: 4px 0;
        padding: 4px 8px;
        border-left: 3px solid #ff6b6b;
        background-color: rgba(255, 107, 107, 0.1);
      }
    `;
    document.head.appendChild(style);

    // --- Helper function to resize image ---
    async function resizeImage(file, maxWidth, maxHeight, quality = 0.8) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (event) => {
          const img = new Image();
          img.onload = () => {
            let width = img.width;
            let height = img.height;

            // Calculate new dimensions while preserving aspect ratio
            if (width > maxWidth) {
              height = Math.round((height * maxWidth) / width);
              width = maxWidth;
            }
            if (height > maxHeight) {
              width = Math.round((width * maxHeight) / height);
              height = maxHeight;
            }

            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, width, height);

            // Get the data URL and extract base64
            const dataUrl = canvas.toDataURL('image/jpeg', quality);
            resolve(dataUrl.split(',')[1]); 
          };
          img.onerror = (error) => {
            console.error('Image loading error:', error);
            reject(new Error('Could not load image for resizing.'));
          };
          img.src = event.target.result;
        };
        reader.onerror = (error) => {
          console.error('File reading error:', error);
          reject(new Error('Could not read file for resizing.'));
        };
        reader.readAsDataURL(file);
      });
    }
    // -------------------------------------

    // Image Upload Logic
    const imageUploadInput = document.getElementById('imageUploadInput');

    uploadImageButton.onclick = () => {
      imageUploadInput.click(); // Trigger hidden file input
    };

    imageUploadInput.onchange = async (event) => { // Make handler async
      const file = event.target.files[0];
      if (!file || !api) { // Add !api check
        return; // No file selected or API not ready
      }

      if (!file.type.startsWith('image/')) { 
        logMessage('Error: Please select an image file.');
        // Reset the input value even if the file is wrong type
        imageUploadInput.value = null; 
        return;
      }

      try {
        // await ensureApiConnected(); // Connection is now ensured by Connect button

        logMessage('You: Resizing and sending uploaded image...');
        // Resize the image (e.g., max 1024x1024, 80% JPEG quality)
        const base64Image = await resizeImage(file, 1024, 1024, 0.8);
        api.sendImage(base64Image);
      } catch (error) {
        console.error('Error processing image:', error);
        logMessage('Error: ' + error.message);
      }

      // Reset the input value to allow uploading the same file again
      imageUploadInput.value = null; 
    };

    // Modality Radio Button Handler
    modalityRadios.forEach(radio => {
      radio.addEventListener('change', (event) => {
        if (event.target.checked) {
          responseModality = event.target.value;
          console.log('Switched response modality to:', responseModality);
        }
      });
    });

    // Connect Button Handler
    connectButton.addEventListener('click', async () => {
      console.log('Connect button clicked.');
      connectButton.disabled = true; // Disable connect button during/after connection
      connectButton.textContent = 'Connecting...';
      try {
        await ensureApiConnected(); // Establish connection
        console.log('Connection successful!');
        connectButton.textContent = 'Connected'; 
        setInteractionButtonsDisabled(false); // Enable interaction buttons
        // Disable Radio Buttons
        modalityAudioRadio.disabled = true;
        modalityTextRadio.disabled = true;
      } catch (error) {
        console.error('Connection failed:', error);
        logMessage('Error: Connection failed. Please check console and refresh.');
        connectButton.textContent = 'Connection Failed';
        // Keep connect button disabled on failure to prevent spamming
        // User needs to refresh
      }
    });
  </script>
</body>
</html>